import { LspClient, Range } from "../ts-lsp-client-dist/src/main";
import { LanguageDriver, TypeSpanAndSourceFile } from "./types";
import { OcamlTypeChecker } from "./ocaml-type-checker";
export declare class OcamlDriver implements LanguageDriver {
    typeChecker: OcamlTypeChecker;
    init(lspClient: LspClient, sketchPath: string): Promise<void>;
    getHoleContext(lspClient: LspClient, sketchFilePath: string): Promise<{
        fullHoverResult: string;
        functionName: string;
        functionTypeSpan: any;
        linePosition: any;
        characterPosition: any;
        holeTypeDefLinePos: number;
        holeTypeDefCharPos: number;
        range: Range;
        source: string;
    }>;
    extractRelevantTypes(lspClient: LspClient, fullHoverResult: string, typeName: string, startLine: number, endLine: number, foundSoFar: Map<string, TypeSpanAndSourceFile>, currentFile: string): Promise<Map<string, TypeSpanAndSourceFile>>;
    extractRelevantHeaders(lspClient: LspClient, sources: string[], relevantTypes: Map<string, TypeSpanAndSourceFile>, holeType: string): Promise<Set<TypeSpanAndSourceFile>>;
    extractHeaderTypeSpans(lspClient: LspClient, preludeFilePath: string): Promise<{
        identifier: string;
        typeSpan: string;
        snippet: string;
    }[]>;
    generateTargetTypes(holeType: string, relevantTypes: Map<string, TypeSpanAndSourceFile>, preludeFilePath: string): Set<string>;
    generateTargetTypesHelper(relevantTypes: Map<string, TypeSpanAndSourceFile>, currType: string, targetTypes: Set<string>): void;
    extractRelevantHeadersHelper(typeSpan: string, targetTypes: Set<string>, relevantTypes: Map<string, TypeSpanAndSourceFile>, relevantContext: Set<TypeSpanAndSourceFile>, snippet: string, source: string): void;
    isTypeEquivalent(t1: string, t2: string, relevantTypes: Map<string, TypeSpanAndSourceFile>): boolean;
    normalize(typeSpan: string, relevantTypes: Map<string, TypeSpanAndSourceFile>): string | undefined;
}
