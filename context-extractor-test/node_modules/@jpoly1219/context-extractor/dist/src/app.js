"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompletionEngine = exports.App = void 0;
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const child_process_1 = require("child_process");
const child_process_2 = require("child_process");
const openai_1 = __importDefault(require("openai"));
const main_1 = require("../ts-lsp-client-dist/src/main");
// import { LspClient, JSONRPCEndpoint } from "ts-lsp-client";
const types_1 = require("./types");
// TODO: Bundle the drivers as barrel exports.
const typescript_driver_1 = require("./typescript-driver");
const ocaml_driver_1 = require("./ocaml-driver");
const utils_1 = require("./utils");
class App {
    constructor(language, sketchPath, repoPath) {
        // private result: {
        //   hole: string;
        //   relevantTypes: string[];
        //   relevantHeaders: string[];
        // } | null = null;
        this.result = null;
        // Optional timeout for forced termination
        this.timeout = setTimeout(() => {
            if (!this.languageServer.killed) {
                console.log('Forcibly killing the process...');
                this.languageServer.kill('SIGKILL');
            }
        }, 5000);
        this.language = language;
        this.sketchPath = sketchPath;
        this.repoPath = repoPath;
        const r = (() => {
            switch (language) {
                case types_1.Language.TypeScript: {
                    this.languageDriver = new typescript_driver_1.TypeScriptDriver();
                    return (0, child_process_1.spawn)("typescript-language-server", ["--stdio"], { stdio: ["pipe", "pipe", "pipe"] });
                }
                case types_1.Language.OCaml: {
                    this.languageDriver = new ocaml_driver_1.OcamlDriver();
                    try {
                        (0, child_process_2.execSync)(`eval $(opam env --switch=. --set-switch)`, { shell: "/bin/bash" });
                        // execSync("opam switch .", { shell: "/bin/bash" })
                        const currDir = __dirname;
                        process.chdir(path.dirname(sketchPath));
                        // execSync("which dune", { shell: "/bin/bash" })
                        (0, child_process_1.spawn)("dune", ["build", "-w"]);
                        process.chdir(currDir);
                    }
                    catch (err) {
                        console.log("ERROR:", err);
                    }
                    // TODO: Spawn a dune build -w on sketch directory.
                    // try {
                    //   execSync("which dune", { shell: "/bin/bash" })
                    //   spawn("dune", ["build", "-w"]);
                    // } catch (err) {
                    //   console.log("ERROR:", err)
                    // }
                    // process.chdir(currDir);
                    return (0, child_process_1.spawn)("ocamllsp", ["--stdio"]);
                }
            }
        })();
        const e = new main_1.JSONRPCEndpoint(r.stdin, r.stdout);
        const c = new main_1.LspClient(e);
        this.languageServer = r;
        this.lspClient = c;
        this.languageServer.on('close', (code) => {
            if (code !== 0) {
                console.log(`ls process exited with code ${code}`);
            }
        });
        // Clear timeout once the process exits
        this.languageServer.on('exit', () => {
            clearTimeout(this.timeout);
            console.log('Process terminated cleanly.');
        });
        // const logFile = fs.createWriteStream("log.txt");
        // r.stdout.on('data', (d) => logFile.write(d));
    }
    async init() {
        await this.languageDriver.init(this.lspClient, this.sketchPath);
    }
    async run() {
        // const outputFile = fs.createWriteStream("output.txt");
        try {
            await this.init();
            const holeContext = await this.languageDriver.getHoleContext(this.lspClient, this.sketchPath);
            const relevantTypes = await this.languageDriver.extractRelevantTypes(this.lspClient, holeContext.fullHoverResult, holeContext.functionName, holeContext.range.start.line, holeContext.range.end.line, new Map(), holeContext.source);
            // Postprocess the map.
            if (this.language === types_1.Language.TypeScript) {
                relevantTypes.delete("_()");
                for (const [k, { typeSpan: v, sourceFile: src }] of relevantTypes.entries()) {
                    relevantTypes.set(k, { typeSpan: v.slice(0, -1), sourceFile: src });
                }
            }
            else if (this.language === types_1.Language.OCaml) {
                relevantTypes.delete("_");
            }
            // console.log(relevantTypes)
            let repo = [];
            if (this.language === types_1.Language.TypeScript) {
                repo = (0, utils_1.getAllTSFiles)(this.repoPath);
            }
            else if (this.language === types_1.Language.OCaml) {
                repo = (0, utils_1.getAllOCamlFiles)(this.repoPath);
            }
            const relevantHeaders = await this.languageDriver.extractRelevantHeaders(this.lspClient, repo, relevantTypes, holeContext.functionTypeSpan);
            // console.log(relevantHeaders)
            // Postprocess the map.
            if (this.language === types_1.Language.TypeScript) {
                relevantTypes.delete("");
                for (const [k, { typeSpan: v, sourceFile: src }] of relevantTypes.entries()) {
                    relevantTypes.set(k, { typeSpan: v + ";", sourceFile: src });
                }
                for (const obj of relevantHeaders) {
                    obj.typeSpan += ";";
                }
            }
            const relevantTypesToReturn = new Map();
            relevantTypes.forEach(({ typeSpan: v, sourceFile: src }, _) => {
                if (relevantTypesToReturn.has(src)) {
                    const updated = relevantTypesToReturn.get(src);
                    updated.push(v);
                    relevantTypesToReturn.set(src, updated);
                }
                else {
                    relevantTypesToReturn.set(src, [v]);
                }
            });
            const relevantHeadersToReturn = new Map();
            relevantHeaders.forEach(({ typeSpan: v, sourceFile: src }) => {
                if (relevantHeadersToReturn.has(src)) {
                    const updated = relevantHeadersToReturn.get(src);
                    if (!updated.includes(v)) {
                        updated.push(v);
                    }
                    relevantHeadersToReturn.set(src, updated);
                }
                else {
                    relevantHeadersToReturn.set(src, [v]);
                }
            });
            this.result = {
                holeType: holeContext.functionTypeSpan,
                relevantTypes: relevantTypesToReturn,
                relevantHeaders: relevantHeadersToReturn
            };
        }
        catch (err) {
            console.error("Error during execution:", err);
            throw err;
        }
        finally {
            // outputFile.end();
        }
    }
    close() {
        // TODO:
        try {
            this.lspClient.exit();
        }
        catch (err) {
            console.log(err);
        }
    }
    getSavedResult() {
        return this.result;
    }
}
exports.App = App;
class CompletionEngine {
    constructor(language, sketchPath, configPath) {
        this.language = language;
        this.config = JSON.parse(fs.readFileSync(configPath, "utf8"));
        this.sketchPath = sketchPath;
    }
    async completeWithLLM(context) {
        let joinedTypes = "";
        let joinedHeaders = "";
        context.relevantTypes.forEach((v, _) => {
            joinedTypes = joinedTypes + v.join("\n") + "\n";
        });
        context.relevantHeaders.forEach((v, _) => {
            joinedHeaders = joinedHeaders + v.join("\n") + "\n";
        });
        // Create a prompt.
        const prompt = this.generateTypesAndHeadersPrompt(
        // fs.readFileSync(path.join(targetDirectoryPath, "sketch.ts"), "utf8"),
        fs.readFileSync(this.sketchPath, "utf8"), context.holeType, joinedTypes, joinedHeaders);
        // Call the LLM to get completion results back.
        const apiBase = this.config.apiBase;
        const deployment = this.config.deployment;
        const model = this.config.gptModel;
        const apiVersion = this.config.apiVersion;
        const apiKey = this.config.apiKey;
        const openai = new openai_1.default({
            apiKey,
            baseURL: `${apiBase}/openai/deployments/${deployment}`,
            defaultQuery: { "api-version": apiVersion },
            defaultHeaders: { "api-key": apiKey }
        });
        const llmResult = await openai.chat.completions.create({
            model,
            messages: prompt,
            temperature: this.config.temperature
        });
        return llmResult.choices[0].message.content;
    }
    generateTypesAndHeadersPrompt(sketchFileContent, holeType, relevantTypes, relevantHeaders) {
        let holeConstruct = "";
        switch (this.language) {
            case types_1.Language.TypeScript: {
                holeConstruct = "_()";
            }
            case types_1.Language.OCaml: {
                holeConstruct = "_";
            }
        }
        const prompt = [{
                role: "system",
                content: [
                    "CODE COMPLETION INSTRUCTIONS:",
                    `- Reply with a functional, idiomatic replacement for the program hole marked '${holeConstruct}' in the provided TypeScript program sketch`,
                    `- Reply only with a single replacement term for the unqiue distinguished hole marked '${holeConstruct}'`,
                    "Reply only with code",
                    "- DO NOT include the program sketch in your reply",
                    "- DO NOT include a period at the end of your response and DO NOT use markdown",
                    "- DO NOT include a type signature for the program hole, as this is redundant and is already in the provided program sketch"
                ].join("\n"),
            }];
        let userPrompt = {
            role: "user",
            content: ""
        };
        if (relevantTypes) {
            userPrompt.content +=
                `# The expected type of the goal completion is ${holeType} #

# The following type definitions are likely relevant: #
${relevantTypes}

      `;
        }
        if (relevantHeaders) {
            userPrompt.content += `
# Consider using these variables relevant to the expected type: #
${relevantHeaders}

      `;
        }
        userPrompt.content += `# Program Sketch to be completed: #\n${(0, utils_1.removeLines)(sketchFileContent).join("\n")}`;
        prompt.push(userPrompt);
        return prompt;
    }
    ;
}
exports.CompletionEngine = CompletionEngine;
